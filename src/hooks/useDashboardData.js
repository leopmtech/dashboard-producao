// ==========================================
// src/hooks/useDashboardData.js - CORRIGIDO COM MARCA√á√ÉO DE FONTES
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import notionService from '../services/notionService';
import dataSourceService from '../services/dataSourceService';
import { DataProcessingService } from '../services/dataProcessingService';

// --- Helpers de merge --- //
const sumSafe = (a = 0, b = 0) => (Number(a) || 0) + (Number(b) || 0);

// ‚úÖ NOVA FUN√á√ÉO: Prepara dados de tend√™ncia com todos os 12 meses
const prepareTrendData = (rawData, currentYear = new Date().getFullYear()) => {
  const allMonths = [
    'Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
    'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
  ];

  const monthsMap = {
    'janeiro': 'Janeiro', 'fevereiro': 'Fevereiro', 'marco': 'Mar√ßo', 'mar√ßo': 'Mar√ßo',
    'abril': 'Abril', 'maio': 'Maio', 'junho': 'Junho', 'julho': 'Julho',
    'agosto': 'Agosto', 'setembro': 'Setembro', 'outubro': 'Outubro',
    'novembro': 'Novembro', 'dezembro': 'Dezembro'
  };

  // Processar dados de visaoGeral para criar dados mensais
  const monthlyTotals = {};
  
  if (rawData && rawData.visaoGeral && Array.isArray(rawData.visaoGeral)) {
    // Inicializar todos os meses com 0
    allMonths.forEach(month => {
      monthlyTotals[month] = 0;
    });

    // Somar os valores de todos os clientes por m√™s
    rawData.visaoGeral.forEach(cliente => {
      Object.keys(monthsMap).forEach(key => {
        if (cliente[key] && typeof cliente[key] === 'number') {
          const monthName = monthsMap[key];
          monthlyTotals[monthName] += cliente[key];
        }
      });
    });
  } else {
    // Se n√£o h√° dados, inicializar todos com 0
    allMonths.forEach(month => {
      monthlyTotals[month] = 0;
    });
  }

  // Criar estrutura final com todos os 12 meses
  const fullYearData = allMonths.map((month, index) => {
    const monthNumber = index + 1;
    const current = monthlyTotals[month] || 0;

    return {
      month,
      monthNumber,
      current,
      previous: 0, // Ser√° calculado abaixo
      growth: 0,   // Ser√° calculado abaixo
      date: `${currentYear}-${monthNumber.toString().padStart(2, '0')}-01`
    };
  });

  // Calcular compara√ß√µes com m√™s anterior
  fullYearData.forEach((item, index) => {
    if (index > 0) {
      const previousMonth = fullYearData[index - 1];
      item.previous = previousMonth.current;
      
      // Calcular crescimento percentual
      if (previousMonth.current > 0) {
        item.growth = ((item.current - previousMonth.current) / previousMonth.current) * 100;
      } else {
        item.growth = item.current > 0 ? 100 : 0;
      }
    } else {
      // Para janeiro, n√£o h√° m√™s anterior no ano atual
      item.previous = 0;
      item.growth = 0;
    }
  });

  console.log('üìä [TREND] Dados de tend√™ncia processados:', {
    totalMeses: fullYearData.length,
    mesesComDados: fullYearData.filter(m => m.current > 0).length,
    primeiros5: fullYearData.slice(0, 5).map(m => ({ mes: m.month, valor: m.current }))
  });

  return fullYearData;
};

// Soma por cliente e meses (janeiro...dezembro), mantendo totais/coer√™ncia
function mergeClientsArrays(a = [], b = []) {
  const map = new Map();

  const push = (item) => {
    if (!item || !item.cliente) return;
    const key = String(item.cliente).trim();
    const prev = map.get(key) || {
      cliente: key,
      total: 0,
      concluidos: 0,
      pendentes: 0,
      atrasados: 0,
      '2024': 0,
      '2025': 0,
      janeiro: 0, fevereiro: 0, marco: 0, abril: 0, maio: 0, junho: 0,
      julho: 0, agosto: 0, setembro: 0, outubro: 0, novembro: 0, dezembro: 0
    };

    const next = {
      ...prev,
      total: sumSafe(prev.total, item.total),
      concluidos: sumSafe(prev.concluidos, item.concluidos),
      pendentes: sumSafe(prev.pendentes, item.pendentes),
      atrasados: sumSafe(prev.atrasados, item.atrasados),
      '2024': sumSafe(prev['2024'], item['2024']),
      '2025': sumSafe(prev['2025'], item['2025']),
      janeiro: sumSafe(prev.janeiro, item.janeiro),
      fevereiro: sumSafe(prev.fevereiro, item.fevereiro),
      marco: sumSafe(prev.marco, item.marco),
      abril: sumSafe(prev.abril, item.abril),
      maio: sumSafe(prev.maio, item.maio),
      junho: sumSafe(prev.junho, item.junho),
      julho: sumSafe(prev.julho, item.julho),
      agosto: sumSafe(prev.agosto, item.agosto),
      setembro: sumSafe(prev.setembro, item.setembro),
      outubro: sumSafe(prev.outubro, item.outubro),
      novembro: sumSafe(prev.novembro, item.novembro),
      dezembro: sumSafe(prev.dezembro, item.dezembro),
    };

    map.set(key, next);
  };

  a.forEach(push);
  b.forEach(push);

  return Array.from(map.values());
}

// ‚úÖ FUN√á√ÉO PARA DEBUGGAR CAMPOS DO NOTION
function debugNotionFields(notionArray) {
  if (!Array.isArray(notionArray) || notionArray.length === 0) return;
  console.log('üîç [NOTION DEBUG] Analisando campos dispon√≠veis...');
  const sample = notionArray.slice(0, 10);
  sample.forEach((record, index) => {
    const allKeys = Object.keys(record || {});
    const clientFields = allKeys.filter(key =>
      key.toLowerCase().includes('client') || key.toLowerCase().includes('cliente')
    );
    console.log(`üîç [NOTION DEBUG] Registro ${index}:`, {
      totalCampos: allKeys.length,
      camposCliente: clientFields,
      valoresCliente: clientFields.reduce((acc, field) => {
        acc[field] = record[field];
        return acc;
      }, {})
    });
  });
}

// ‚úÖ FUN√á√ÉO PARA VERIFICAR ESPECIFICAMENTE O CAMPO "Cliente"
function debugNotionClientField(notionArray) {
  if (!Array.isArray(notionArray) || notionArray.length === 0) return;
  console.log('üîç [NOTION CLIENTE] Analisando campo "Cliente" especificamente...');

  const analise = {
    totalRegistros: notionArray.length,
    comCampoCliente: 0,
    semCampoCliente: 0,
    valoresUnicos: new Set(),
    valoresVazios: 0,
    valoresNulos: 0,
    amostraValores: []
  };

  notionArray.forEach((record, index) => {
    const valorCliente = record?.Cliente;

    if (valorCliente === null || valorCliente === undefined) {
      analise.valoresNulos++;
      analise.semCampoCliente++;
    } else if (typeof valorCliente === 'string' && valorCliente.trim() === '') {
      analise.valoresVazios++;
      analise.semCampoCliente++;
    } else if (typeof valorCliente === 'string' && valorCliente.trim().length > 0) {
      analise.comCampoCliente++;
      analise.valoresUnicos.add(valorCliente.trim());

      if (analise.amostraValores.length < 20) {
        analise.amostraValores.push({
          index,
          valor: valorCliente.trim(),
          contemMultiplos: valorCliente.includes(',') || valorCliente.includes('/')
        });
      }
    } else {
      analise.semCampoCliente++;
    }
  });

  console.log('üîç [NOTION CLIENTE] An√°lise do campo "Cliente":');
  console.log(`  üìä Total de registros: ${analise.totalRegistros}`);
  console.log(`  ‚úÖ Com campo Cliente preenchido: ${analise.comCampoCliente}`);
  console.log(`  ‚ùå Sem campo Cliente: ${analise.semCampoCliente}`);
  console.log(`  üìä Valores √∫nicos detectados: ${analise.valoresUnicos.size}`);
  console.log(`  üîç Taxa de preenchimento: ${((analise.comCampoCliente / analise.totalRegistros) * 100).toFixed(1)}%`);

  console.log('üìã [AMOSTRA] Primeiros 20 valores do campo "Cliente":');
  analise.amostraValores.forEach(item => {
    console.log(`  ${item.index}: "${item.valor}" ${item.contemMultiplos ? 'üîÄ (m√∫ltiplos)' : ''}`);
  });

  console.log('üìã [VALORES √öNICOS] Todos os valores √∫nicos detectados:');
  console.log(Array.from(analise.valoresUnicos).sort());

  return analise;
}

// Unifica contentTypes no formato { id, label, value } com dedupe e normaliza√ß√£o
function dedupeContentTypes(listA = [], listB = []) {
  console.log('üîó [MERGE] Consolidando tipos de conte√∫do...');
  console.log('üîó [MERGE] Lista A (Notion):', listA.length, 'itens');
  console.log('üîó [MERGE] Lista B (Sheets):', listB.length, 'itens');
  
  const byId = new Map();
  
  // Fun√ß√£o para escolher a melhor vers√£o entre duas strings
  const escolherMelhorVersao = (versaoA, versaoB) => {
    if (!versaoA) return versaoB;
    if (!versaoB) return versaoA;
    
    // Crit√©rio 1: Preferir vers√£o com primeira letra mai√∫scula
    const primeiraLetraA = versaoA.charAt(0);
    const primeiraLetraB = versaoB.charAt(0);
    
    const aTemMaiuscula = primeiraLetraA === primeiraLetraA.toUpperCase();
    const bTemMaiuscula = primeiraLetraB === primeiraLetraB.toUpperCase();
    
    if (aTemMaiuscula && !bTemMaiuscula) return versaoA;
    if (!aTemMaiuscula && bTemMaiuscula) return versaoB;
    
    // Crit√©rio 2: Preferir vers√£o com mais palavras capitalizadas
    const palavrasCapitalizadasA = (versaoA.match(/\b[A-Z]/g) || []).length;
    const palavrasCapitalizadasB = (versaoB.match(/\b[A-Z]/g) || []).length;
    
    if (palavrasCapitalizadasA > palavrasCapitalizadasB) return versaoA;
    if (palavrasCapitalizadasB > palavrasCapitalizadasA) return versaoB;
    
    // Crit√©rio 3: Preferir vers√£o mais longa (mais completa)
    if (versaoA.length > versaoB.length) return versaoA;
    if (versaoB.length > versaoA.length) return versaoB;
    
    // Se tudo igual, manter a primeira vers√£o
    return versaoA;
  };
  
  const push = (it, fonte) => {
    if (!it) return;
    
    const fallback = String(it.value || it.label || it.id || '').trim();
    if (!fallback) return;
    
    // Gerar ID normalizado (lowercase, sem espa√ßos, sem acentos)
    const idNormalizado = fallback.toLowerCase()
      .replace(/\s+/g, '_')
      .replace(/[√°√†√¢√£√§]/g, 'a')
      .replace(/[√©√®√™√´]/g, 'e')
      .replace(/[√≠√¨√Æ√Ø]/g, 'i')
      .replace(/[√≥√≤√¥√µ√∂]/g, 'o')
      .replace(/[√∫√π√ª√º]/g, 'u')
      .replace(/[√ß]/g, 'c')
      .replace(/[^a-z0-9_]/g, '');
    
    if (!idNormalizado) return;
    
    const novoLabel = it.label || it.value || it.id || fallback;
    const novoValue = it.value || it.label || it.id || fallback;
    
    // Se j√° existe, escolher a melhor vers√£o
    if (byId.has(idNormalizado)) {
      const existente = byId.get(idNormalizado);
      const melhorLabel = escolherMelhorVersao(existente.label, novoLabel);
      const melhorValue = escolherMelhorVersao(existente.value, novoValue);
      
      console.log(`üîÑ [MERGE] Conflito resolvido: "${existente.label}" vs "${novoLabel}" ‚Üí "${melhorLabel}"`);
      
      byId.set(idNormalizado, {
        id: idNormalizado,
        label: melhorLabel,
        value: melhorValue
      });
    } else {
      // Primeiro encontro
      console.log(`‚ûï [MERGE] Novo tipo (${fonte}): "${novoLabel}"`);
      byId.set(idNormalizado, {
        id: idNormalizado,
        label: novoLabel,
        value: novoValue
      });
    }
  };
  
  // Processar listas (Notion primeiro, depois Sheets para dar prioridade ao Sheets)
  listA.forEach(item => push(item, 'Notion'));
  listB.forEach(item => push(item, 'Sheets'));
  
  const resultado = Array.from(byId.values()).sort((x, y) => 
    x.label.localeCompare(y.label, 'pt-BR')
  );
  
  console.log('üîó [MERGE] === CONSOLIDA√á√ÉO FINAL ===');
  console.log(`‚úÖ [MERGE] Tipos √∫nicos consolidados: ${resultado.length}`);
  console.log('üîó [MERGE] Primeiros 10:', resultado.slice(0, 10).map(r => r.label));
  
  return resultado;
}

// Merge gen√©rico: se ambos s√£o arrays e parecem "mensal por cliente", soma por m√™s; caso contr√°rio concatena (com dedupe).
const mergeColecaoPorClienteEMes = (baseArr = [], rtArr = []) => {
  const index = new Map();
  const coerce = (v) => (typeof v === 'number' && !Number.isNaN(v) ? v : 0);
  const meses = ['janeiro','fevereiro','marco','abril','maio','junho','julho','agosto','setembro','outubro','novembro','dezembro'];
  const clone = (x) => JSON.parse(JSON.stringify(x));

  for (const item of baseArr) {
    if (!item || !item.cliente) continue;
    index.set(item.cliente, clone(item));
  }
  for (const item of rtArr) {
    if (!item || !item.cliente) continue;
    const curr = index.get(item.cliente) || { cliente: item.cliente };
    for (const m of meses) curr[m] = coerce(curr[m]) + coerce(item[m]);
    if (typeof curr.total === 'number' || typeof item.total === 'number') {
      curr.total = coerce(curr.total) + coerce(item.total);
    }
    if (item.tipo && !curr.tipo) curr.tipo = item.tipo;
    index.set(item.cliente, curr);
  }
  return Array.from(index.values());
};

const mergeColecoes = (sheetsData = {}, notionData = {}) => {
  const result = { ...sheetsData };
  for (const [key, value] of Object.entries(notionData)) {
    if (key === 'lastUpdate' || key === 'type') continue;

    const baseVal = result[key];
    if (Array.isArray(baseVal) && Array.isArray(value)) {
      const pareceMensal = value.some(v => v && typeof v === 'object' && ('cliente' in v));
      if (pareceMensal) {
        result[key] = mergeColecaoPorClienteEMes(baseVal, value);
      } else {
        const seen = new Set(baseVal.map(v => JSON.stringify(v)));
        for (const v of value) {
          const s = JSON.stringify(v);
          if (!seen.has(s)) { baseVal.push(v); seen.add(s); }
        }
        result[key] = baseVal;
      }
    } else if (baseVal === undefined) {
      result[key] = value;
    } else {
      // Conflitos n√£o-array: prioriza Notion (tempo real)
      result[key] = value;
    }
  }
  result.lastUpdate = notionData.lastUpdate || sheetsData.lastUpdate || new Date().toISOString();
  return result;
};

// Deduplica√ß√£o simples de orders por id (ou hash do conte√∫do)
const dedupeOrders = (a = [], b = []) => {
  const keyOf = (o) => o?.id || o?.orderId || JSON.stringify(o);
  const seen = new Set();
  const out = [];
  for (const src of [a, b]) {
    for (const o of (src || [])) {
      const k = keyOf(o);
      if (!seen.has(k)) { seen.add(k); out.push(o); }
    }
  }
  return out;
};

// üÜï PASSO 2: Fun√ß√£o de valida√ß√£o de estrutura de dados
function validateDataStructure(data, source) {
  if (!Array.isArray(data)) {
    console.warn(`‚ö†Ô∏è [DATA VALIDATION] ${source}: dados n√£o s√£o um array`);
    return [];
  }
  
  // Campos obrigat√≥rios (Notion usa cliente1, n√£o cliente)
  const requiredFields = ['cliente1', 'cliente', 'dataEntrega', 'tipoDemanda'];
  const issues = [];
  const fieldCounts = {};
  
  data.forEach((item, index) => {
    // Verificar se pelo menos um campo de cliente existe
    const hasCliente = item.cliente1 || item.cliente || item.Cliente;
    
    if (!hasCliente) {
      issues.push({
        index,
        field: 'cliente (qualquer)',
        item: { 
          id: item.id, 
          source, 
          ordemServico: item.ordemServico,
          availableFields: Object.keys(item)
        }
      });
    }
    
    // Contar campos presentes
    requiredFields.forEach(field => {
      if (item[field]) {
        fieldCounts[field] = (fieldCounts[field] || 0) + 1;
      }
    });
  });
  
  if (issues.length > 0) {
    console.error(`‚ùå [DATA VALIDATION] ${source}: ${issues.length} problemas encontrados (primeiros 10):`, issues.slice(0, 10));
    console.warn(`‚ö†Ô∏è [DATA VALIDATION] Total de registros: ${data.length}, Registros sem cliente: ${issues.length}`);
  } else {
    console.log(`‚úÖ [DATA VALIDATION] ${source}: todos os ${data.length} registros t√™m cliente`);
  }
  
  // Log adicional de distribui√ß√£o de campos
  console.log(`üìä [DATA VALIDATION] ${source} - Distribui√ß√£o de campos:`, fieldCounts);
  
  return issues;
}

const useDashboardData = () => {
  // Estados principais
  const [data, setData] = useState(null);
  const [rawData, setRawData] = useState(null);
  const [uniqueDemandTypes, setUniqueDemandTypes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastUpdate, setLastUpdate] = useState(new Date());
  
  // üÜï Estados para debug - dados intermedi√°rios
  const [notionData, setNotionData] = useState(null);
  const [sheetsData, setSheetsData] = useState(null);
  const [consolidatedData, setConsolidatedData] = useState(null);

  // Estado extra para debug de fontes
  const [sourceStatus, setSourceStatus] = useState({
    notionOk: false,
    sheetsOk: false,
    notionClients: 0,
    sheetsClients: 0,
    notionOrders: 0,
    sheetsOrders: 0,
  });

  // Filtros (compat√≠veis com App.js)
  const [activeFilters, setActiveFilters] = useState({
    periodo: 'ambos',
    tipo: 'geral',
    cliente: 'todos',
    tipoDemandaOriginal: 'todos',
  });
  const [filteredData, setFilteredData] = useState(null);

  // === BUSCA DE DADOS (Notion + Sheets) ===
  const fetchData = useCallback(async (useCache = true) => {
    setLoading(true);
    setError(null);

    try {
      console.log('üìä [NOTION ONLY] Carregando dados apenas do Notion...');

      // ‚úÖ USAR APENAS NOTION
      const notionResponse = await fetch('http://localhost:8000/api/notion/orders');
      
      if (!notionResponse.ok) {
        throw new Error(`Erro na API Notion: ${notionResponse.status}`);
      }
      
      const notionData = await notionResponse.json();
      
      // üÜï SET DEBUG STATE
      setNotionData(notionData);
      
      // üÜï PASSO 2: Validar estrutura dos dados do Notion
      validateDataStructure(notionData?.originalOrders || [], 'Notion');
      
      // ‚ùå REMOVER GOOGLE SHEETS
      let sheetsData = null;
      
      // üÜï SET DEBUG STATE
      setSheetsData(sheetsData);
      
      // üÜï PASSO 2: Validar estrutura dos dados do Sheets (se existir)
      if (sheetsData?.originalOrders) {
        validateDataStructure(sheetsData.originalOrders, 'Sheets');
      }

      // üÜï PASSO 2: Consolidar dados de clientes ANTES da consolida√ß√£o principal
      console.log('üîÑ [CONSOLIDATION] Consolidando dados de clientes...');
      const notionRawDataConsolidated = DataProcessingService.consolidateClientData(notionData?.originalOrders || []);
      const sheetsRawDataConsolidated = sheetsData?.originalOrders 
        ? DataProcessingService.consolidateClientData(sheetsData.originalOrders) 
        : [];

      // üÜï CONSOLIDA√á√ÉO COM MARCA√á√ÉO DE FONTES
      console.log('üîÑ [DATA CONSOLIDATION] Aplicando consolida√ß√£o com marca√ß√£o de fontes...');
      
      // Preparar dados brutos para consolida√ß√£o (agora com clientes consolidados)
      const sheetsRawData = sheetsRawDataConsolidated;
      const notionRawData = notionRawDataConsolidated;
      
      console.log('üîç [DEBUG] Dados brutos para consolida√ß√£o:', {
        sheetsRawLength: sheetsRawData.length,
        notionRawLength: notionRawData.length,
        sheetsSample: sheetsRawData.slice(0, 2),
        notionSample: notionRawData.slice(0, 2)
      });
      
      // Aplicar consolida√ß√£o do DataProcessingService
      const consolidatedRawData = DataProcessingService.consolidateAndNormalize(sheetsRawData, notionRawData);
      
      console.log('‚úÖ [CONSOLIDATED RAW] Dados brutos consolidados:', {
        total: consolidatedRawData?.length || 0,
        porFonte: {
          sheets: consolidatedRawData?.filter(item => item._source === 'sheets')?.length || 0,
          notion: consolidatedRawData?.filter(item => item._source === 'notion')?.length || 0
        }
      });

      // Atualiza status de fontes
      setSourceStatus({
        notionOk: !!(notionData && notionData.visaoGeral),
        sheetsOk: !!(sheetsData && sheetsData.visaoGeral),
        notionClients: notionData?.visaoGeral?.length || 0,
        sheetsClients: sheetsData?.visaoGeral?.length || 0,
        notionOrders: notionData?.originalOrders?.length || 0,
        sheetsOrders: sheetsData?.originalOrders?.length || 0,
      });
      
      console.log('üîç [DEBUG] Status das fontes:', {
        notionOk: !!(notionData && notionData.visaoGeral),
        sheetsOk: !!(sheetsData && sheetsData.visaoGeral),
        notionClients: notionData?.visaoGeral?.length || 0,
        sheetsClients: sheetsData?.visaoGeral?.length || 0,
        notionOrders: notionData?.originalOrders?.length || 0,
        sheetsOrders: sheetsData?.originalOrders?.length || 0,
      });

      if (!notionData && !sheetsData) {
        throw new Error('Falha ao carregar Notion e Google Sheets.');
      }

      // Merge gen√©rico de todas cole√ß√µes conhecidas
      const baseMerged = mergeColecoes(sheetsData || {}, notionData || {});

      // Mesclar originalOrders com dedupe
      const originalOrdersMerged = dedupeOrders(
        notionData?.originalOrders || [],
        sheetsData?.originalOrders || []
      );

      // üÜï MARCAR originalOrders COM FONTE
      const originalOrdersMarked = originalOrdersMerged.map((order, index) => ({
        ...order,
        _source: order._source || 'sheets', // Assume sheets se n√£o marcado
        _id: order._id || `order_${index}`,
        _originalIndex: index
      }));

      // Mesclar visaoGeral por cliente somando campos
      const visaoGeralMerged = mergeClientsArrays(
        notionData?.visaoGeral || [],
        sheetsData?.visaoGeral || []
      );

      // üÜï MARCAR visaoGeral COM FONTE
      const visaoGeralMarked = visaoGeralMerged.map((cliente, index) => ({
        ...cliente,
        _source: 'processed', // Dados processados (merge)
        _id: `client_${index}`,
        _originalIndex: index
      }));

      // Unir contentTypes
      console.log('üîç [DEBUG] ContentTypes antes do merge:', {
        notionContentTypes: notionData?.contentTypes?.length || 0,
        sheetsContentTypes: sheetsData?.contentTypes?.length || 0,
        notionSample: notionData?.contentTypes?.slice(0, 3) || [],
        sheetsSample: sheetsData?.contentTypes?.slice(0, 3) || []
      });
      
      const contentTypesMerged = dedupeContentTypes(
        notionData?.contentTypes || [],
        sheetsData?.contentTypes || []
      );

      // ‚úÖ PROCESSAR DADOS DE TEND√äNCIA COM TODOS OS 12 MESES
      const trendDataProcessed = prepareTrendData({ visaoGeral: visaoGeralMerged });

      // Montar payload final no shape usado pelo App
      const merged = {
        ...baseMerged, // inclui outras cole√ß√µes que porventura seu app use
        totalSheets: (notionData ? 1 : 0) + (sheetsData ? 1 : 0),
        loadedAt: new Date().toISOString(),
        sheetName: 'notion+sheets',
        
        // üÜï DADOS PRINCIPAIS COM MARCA√á√ÉO DE FONTE
        originalOrders: originalOrdersMarked,
        _consolidatedSource: consolidatedRawData, // Para o indicador no App.js
        
        metrics: notionData?.metrics || sheetsData?.metrics || {},
        contentTypes: contentTypesMerged,

        // ‚úÖ ADICIONANDO DADOS DE TEND√äNCIA PROCESSADOS
        trend: trendDataProcessed,

        // Cole√ß√µes principais padronizadas COM MARCA√á√ÉO
        visaoGeral: visaoGeralMarked,
        visaoGeral2024: visaoGeralMarked.filter(c => (c['2024'] || 0) > 0),
        diarios: visaoGeralMarked,
        diarios2024: visaoGeralMarked.filter(c => (c['2024'] || 0) > 0),
        semanais: visaoGeralMarked,
        semanais2024: visaoGeralMarked.filter(c => (c['2024'] || 0) > 0),
        mensais: visaoGeralMarked,
        mensais2024: visaoGeralMarked.filter(c => (c['2024'] || 0) > 0),
        especiais: visaoGeralMarked,
        especiais2024: visaoGeralMarked.filter(c => (c['2024'] || 0) > 0),
        diagnosticos: visaoGeralMarked,
        diagnosticos2024: visaoGeralMarked.filter(c => (c['2024'] || 0) > 0),
        design: visaoGeralMarked
      };

      console.log('üéâ [SUCCESS] Dados consolidados e marcados:', {
        consolidatedSource: merged._consolidatedSource?.length || 0,
        originalOrders: merged.originalOrders?.length || 0,
        visaoGeral: merged.visaoGeral?.length || 0,
        fontes: {
          sheets: merged._consolidatedSource?.filter(item => item._source === 'sheets')?.length || 0,
          notion: merged._consolidatedSource?.filter(item => item._source === 'notion')?.length || 0
        }
      });

      setRawData(merged);
      setData(merged);
      
      // üÜï SET DEBUG STATE
      setConsolidatedData(merged);
      
      // üÜï PASSO 2: Validar estrutura dos dados consolidados
      validateDataStructure(merged?.originalOrders || [], 'Consolidado');
      
      setUniqueDemandTypes(contentTypesMerged);
      setLastUpdate(new Date());
      setError(null);

    } catch (err) {
      console.error('‚ùå Erro ao carregar fontes:', err);
      setError(err.message || 'Falha ao carregar dados');
      setData(null);
      setRawData(null);
      setUniqueDemandTypes([]);
    } finally {
      setLoading(false);
    }
  }, []);

  // Aplicar filtros aos dados
  const applyFilters = useCallback(() => {
    if (!data) {
      setFilteredData(null);
      return;
    }
    try {
      const filtered = DataProcessingService.applyAdvancedFilters
        ? DataProcessingService.applyAdvancedFilters(data, activeFilters)
        : data;
      
      // ‚úÖ REPROCESSAR TREND DATA PARA DADOS FILTRADOS
      if (filtered && filtered.visaoGeral) {
        filtered.trend = prepareTrendData(filtered);
      }
      
      setFilteredData(filtered);
      console.log('üîç Filtros aplicados:', {
        filtros: activeFilters,
        ordens: filtered?.originalOrders?.length || 0,
        clientes: filtered?.visaoGeral?.length || 0,
        trendMeses: filtered?.trend?.length || 0,
        fonte: data?.sheetName || 'desconhecida',
      });
    } catch (e) {
      console.error('‚ùå Erro ao aplicar filtros:', e);
      setFilteredData(data);
    }
  }, [data, activeFilters]);

  // Atualizar filtro
  const updateFilter = useCallback((filterType, value) => {
    setActiveFilters((prev) => {
      const newFilters = { ...prev, [filterType]: value };
      if (filterType === 'tipoDemandaOriginal') newFilters.tipo = 'geral';
      console.log('üîß Atualizando filtro:', { [filterType]: value });
      return newFilters;
    });
  }, []);

  const clearFilters = useCallback(() => {
    setActiveFilters({
      periodo: 'ambos',
      tipo: 'geral',
      cliente: 'todos',
      tipoDemandaOriginal: 'todos',
    });
  }, []);

  const refreshData = useCallback(async () => {
    await fetchData(false);
  }, [fetchData]);

  const exportData = useCallback(async (format = 'csv') => {
    try {
      console.log('üì§ Exportando dados em formato:', format);
      const dataToExport = filteredData || data;
      if (!dataToExport || !dataToExport.visaoGeral) {
        throw new Error('Nenhum dado dispon√≠vel para exportar');
      }
      const csvData = dataToExport.visaoGeral.map((cliente) => ({
        Cliente: cliente.cliente,
        Total: cliente.total || 0,
        Concluidos: cliente.concluidos || 0,
        Pendentes: cliente.pendentes || 0,
        Atrasados: cliente.atrasados || 0,
        '2024': cliente['2024'] || 0,
        '2025': cliente['2025'] || 0,
        Janeiro: cliente.janeiro || 0,
        Fevereiro: cliente.fevereiro || 0,
        Marco: cliente.marco || 0,
        Abril: cliente.abril || 0,
        Maio: cliente.maio || 0,
        Junho: cliente.junho || 0,
        Julho: cliente.julho || 0,
        Agosto: cliente.agosto || 0,
        Setembro: cliente.setembro || 0,
        Outubro: cliente.outubro || 0,
        Novembro: cliente.novembro || 0,
        Dezembro: cliente.dezembro || 0
      }));

      const header = Object.keys(csvData[0] || {}).join(',');
      const rows = csvData.map((row) => Object.values(row).join(','));
      const csvContent = [header, ...rows].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `dashboard-export-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      console.log('‚úÖ Dados exportados com sucesso');
    } catch (err) {
      console.error('‚ùå Erro ao exportar dados:', err);
      throw err;
    }
  }, [data, filteredData]);

  // Efeitos
  useEffect(() => { fetchData(true); }, [fetchData]);
  useEffect(() => { applyFilters(); }, [applyFilters]);

  // ‚úÖ DEBUG: Verificar campos vindos do Notion (amostra)
  useEffect(() => {
    if (notionData && Array.isArray(notionData.originalOrders) && notionData.originalOrders.length > 0) {
      debugNotionFields(notionData.originalOrders);
    }
  }, [notionData]);

  // ‚úÖ DEBUG: Verificar especificamente o campo "Cliente" do Notion
  useEffect(() => {
    if (notionData && Array.isArray(notionData.originalOrders) && notionData.originalOrders.length > 0) {
      debugNotionClientField(notionData.originalOrders);
      console.log('üìä [NOTION ONLY] Carregando dados apenas do Notion...');
    }
  }, [notionData]);

  const hasActiveFilters = Object.entries(activeFilters).some(([k, v]) => {
    const defaults = { periodo: 'ambos', tipo: 'geral', cliente: 'todos', tipoDemandaOriginal: 'todos' };
    return v !== defaults[k];
  });

  const dataToReturn = filteredData || data;

  return {
    data: dataToReturn,
    rawData,
    loading,
    error,
    lastUpdate,

    uniqueDemandTypes,

    activeFilters,
    hasActiveFilters,

    refreshData,
    exportData,
    updateFilter,
    clearFilters,

    // Estat√≠sticas √∫teis + status das fontes
    stats: {
      totalOrders: data?.originalOrders?.length || 0,
      filteredOrders: dataToReturn?.originalOrders?.length || 0,
      totalClients: data?.visaoGeral?.length || 0,
      filteredClients: dataToReturn?.visaoGeral?.length || 0,
      uniqueTypesCount: uniqueDemandTypes.length,
      fonte: data?.sheetName || 'desconhecida'
    },
    sourceStatus,
    
    // üÜï DEBUG STATES
    notionData,
    sheetsData,
    consolidatedData
  };
};

export default useDashboardData;